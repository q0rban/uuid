<?php
// $Id$

/**
 * @file
 * Main module functions for the uuid module.
 */

// Generic Hooks

/**
 * Implements of hook_menu().
 */
function uuid_menu() {
  $items = array();

  $items['admin/config/system/uuid'] = array(
    'title' => 'Universally Unique IDentifier',
    'description' => 'Configure automatically UUID generation settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uuid_admin'),
    'access arguments' => array('administer uuid'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'uuid.admin.inc',
  );

  $items['uuid/%'] = array(
    'title' => 'Universally Unique IDentifier Lookup',
    'description' => 'Find entities by UUID.',
    'page callback' => 'uuid_goto',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['uuid/%/revision'] = array(
    'title' => 'Universally Unique IDentifier Lookup',
    'description' => 'Find entities by UUID.',
    'page callback' => 'uuid_goto',
    'page arguments' => array(1, FALSE),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements of hook_permissions().
 */
function uuid_permissions() {
  return array('administer uuid');
}

// UUID functions
/**
 * Finds an entity record by UUID.
 *
 * @param $uuid
 *  The UUID to use for the lookup.
 */
function uuid_find($uuid) {

  foreach (variable_get('uuid_fields', array()) as $name) {
    $query = new EntityFieldQuery;
    $results = $query
      ->fieldCondition($name, 'uuid', $uuid)
      ->age(FIELD_LOAD_REVISION)
      ->execute();

    // UUIDs are unique so return as soon as we have a result
    if ($results) {
      return $results;
    }
  }

  return array();
}
/**
 * Finds an entity record by UUID.
 *
 * @param $uuid
 *  The UUID to use for the lookup.
 *
 * @param $find_latest
 *  Find the latest version of the record.
 */
function uuid_goto($uuid, $find_latest = TRUE) {

  if (!uuid_is_well_formed($uuid)) {
    drupal_set_message(t('Supplied value is not a UUID.'), 'error');
    drupal_goto('<front>');
    return;
  }

  $results = uuid_find($uuid);

  if (!$results) {
    drupal_set_message(t('Invalid UUID.'), 'error');
    drupal_goto('<front>');
  }

  list($entity_type, $stub_entities) = each($results);

  $entity_info = entity_get_info();
  $structure = $entity_info[$entity_type];
  unset($entity_info);

  $entity = reset($stub_entities);

  if ($entity_type == 'node' && !$find_latest) {
    $path = sprintf('node/%d/revisions/%d/view', $entity->{$structure['entity keys']['id']}, $entity->{$structure['entity keys']['revision']});
  }
  else {
    $uri = $structure['uri callback']($entity);
    $path = $uri['path'];
  }

  drupal_goto($path);
  return;
}

/**
 * Check that a string appears to be in the format of a UUID.
 *
 * @param $uuid
 *  The string to test.
 *
 * @return
 *   Returns TRUE is the string is well formed.
 */
function uuid_is_well_formed($uuid) {
  return preg_match("/^[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}$/", $uuid);
}

// Field Hooks

/**
 * Implements hook_field_info().
 */
function uuid_field_info() {
  return array(
    'uuid' => array(
      'label' => t('Universally Unique IDentifier'),
      'description' => t('Stores a Universally Unique IDentifier'),
      'default_widget' => 'hidden_value',
      'default_formatter' => 'hidden',
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function uuid_field_is_empty($item, $field) {
  return empty($item['uuid']);
}

/**
 * Implements hook_field_attach_presave().
 */
function uuid_field_attach_presave($entity_type, $entity) {

  foreach (field_info_fields() as $name => $field) {

    $bundles = array();
    foreach ($field['bundles'] as $bundle) {
      $bundles += array_keys($bundle);
    }

    if ('uuid' === $field['type'] && in_array($name, $bundles)) {
      // We only set the UUID for new records or new revisions
      if (empty($entity->{$name}[LANGUAGE_NONE][0])
        || (isset($entity->revision) && $entity->revision === 1)) {
        $entity->{$name}[LANGUAGE_NONE][0]['uuid'] = uuid_uuid();
      }
    }
  }
}

/**
 * Implements hook_field_widget_info_alter().
 */
function uuid_field_widget_info_alter(&$info) {
  $info['hidden_value']['field types'][] = 'uuid';
}

/**
 * Implements hook_field_create_field().
 *
 * Ensures cardinality is always 1 and errors if it doesn't.
 *
 * @throws FieldException
 */
function uuid_field_create_field($field) {
  if ('uuid' == $field['type']) {
    // Ensure cardinality isn't greater than 1.
    if ($field['cardinality'] > 1) {
      field_delete_field($field['field_name']);

      db_delete('field_config')
        ->condition('id', $field['id'])
        ->execute();

      field_cache_clear(TRUE);

      throw new FieldException(t("Cardinality for @type must always be 1.", array('@field_name' => $field['type'])));
    }
    else {
      $field_info = variable_get('uuid_fields', array());
      $field_info[$field['field_name']] = $field['field_name'];
      variable_set('uuid_fields', $field_info);
    }
  }
}

/**
 * Implements hook_field_delete_field().
 */
function uuid_field_delete_field($field) {
  $field_info = variable_get('uuid_fields', array());
  // All is good if cardinality is one, so exit early
  if (!empty($field_info[$field['field_name']])) {
    unset($field_info[$field['field_name']]);
    variable_set('uuid_fields', $field_info);
  }
}

/**
 * Implements hook_field_update_field().
 *
 * Ensures cardinality is always 1.
 *
 * This is a hack around field_ui not catching FieldUpdateForbiddenException 
 * from hook_field_update_forbid() implementors. See http://drupal.org/node/1014506
 * 
 */
function uuid_field_update_field($field, $prior_field, $has_data) {
  if ('uuid' == $field['type'] && 1 != $field['cardinality']) {
    $field['cardinality'] = 1;
    field_update_field($field);
    drupal_set_message(t("Cardinality for @field_name must always be 1.", array('@field_name' => $field['field_name'])), 'error');
  }
}

// Form Hacks

/**
 * Implements hook_form_alter().
 *
 * This improves UX by hiding the forced value.
 */
function uuid_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  $columns = array_keys($form['#field']['columns']);
  if ('uuid' == $columns[0]) {
    $form['field']['#type'] = 'value';
    $form['field']['cardinality'] = array(
      '#type' => 'value',
      '#value' => 1,
    );
  }
}

// UUID generators

/**
 * Fetches information about the available UUID implementations.
 */
function uuid_info() {
  return module_invoke_all('uuid_info');
}

/**
 * Implements hook_uuid_info().
 */
function uuid_uuid_info() {
  $sources = array();

  // PECL and OSSP are 2 incompatiable implementations in PHP that use the same namespace.
  if (function_exists('uuid_create') && !function_exists('uuid_make')) {
    $sources['pecl'] = array(
      'callback' => 'uuid_pecl',
      'title' => t('PECL Extension'),
    );
  }

  if (Database::getConnection()->databaseType() == 'mysql') {
    $sources['mysql'] = array(
      'callback' => 'uuid_mysql',
      'title' => t('MySQL - SELECT UUID()'),
    );
  }

  if (function_exists('com_create_guid')) {
    $sources['com'] = array(
      'callback' => 'uuid_com',
      'title' => t('Windows COM'),
    );
  }

  $sources['php'] = _uuid_uuid_php_info();

  return $sources;
}

/**
 * Fetches the PHP fallback generator config.
 *
 * This is used to keep 
 */
function _uuid_uuid_php_info() {
 return array(
    'callback' => 'uuid_php',
    'title' => t('PHP Fallback'),
  );
}

/**
 * Generates an Universally Unique IDentifier (UUID).
 *
 * @return
 *   An UUID, made up of 32 hex digits and 4 hyphens.
 */
function uuid_uuid() {
  static $callback;
  if (is_null($callback)) {
    $var_name = 'uuid_generator';
    $generator = variable_get($var_name, NULL);
    if (!is_null($generator) && isset($generators[$generator])) {
      $config = $generators[$generator];
    }
    else {
      $config = _uuid_uuid_php_info();
      variable_set($var_name, 'php');
    }

    if (isset($config['include'])) {
      drupal_load($config['include']['module'], $config['include']['filename']);
    }

    $callback = $config['callback'];
  }
  return $callback();
}

/**
 * Generates a UUID using the Windows internal GUID generator.
 *
 * See http://php.net/com_create_guid
 */
function uuid_com() {
  return trim(com_create_guid(), '{}');
}

/**
 * Generates a UUID using MySQL's implementation.
 *
 * See http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_uuid
 */
function uuid_mysql() {
  return db_query('SELECT UUID()')->fetchField();
}

/**
 * Generates a UUID using the PECL extension.
 *
 * See http://pecl.php.net/package/uuid
 */
function uuid_pecl() {
  return uuid_create(UUID_TYPE_DEFAULT);
}

/**
 * Generates a UUID v4 using PHP code.
 *
 * See http://php.net/uniqid#65879
 */
function uuid_php() {
  // The field names refer to RFC 4122 section 4.1.2.
  return sprintf('%04x%04x-%04x-%03x4-%04x-%04x%04x%04x',
    // 32 bits for "time_low".
    mt_rand(0, 65535), mt_rand(0, 65535),
    // 16 bits for "time_mid".
    mt_rand(0, 65535),
    // 12 bits before the 0100 of (version) 4 for "time_hi_and_version".
    mt_rand(0, 4095),
    bindec(substr_replace(sprintf('%016b', mt_rand(0, 65535)), '01', 6, 2)),
    // 8 bits, the last two of which (positions 6 and 7) are 01, for "clk_seq_hi_res"
    // (hence, the 2nd hex digit after the 3rd hyphen can only be 1, 5, 9 or d)
    // 8 bits for "clk_seq_low" 48 bits for "node".
    mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(0, 65535)
  );
}


